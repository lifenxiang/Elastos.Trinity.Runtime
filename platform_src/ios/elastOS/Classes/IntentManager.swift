 /*
  * Copyright (c) 2020 Elastos Foundation
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  */

 import Foundation
 import SwiftJWT
 import AnyCodable
 import PopupDialog
 import ElastosDIDSDK

 extension AnyCodable : SwiftJWT.Claims {}

 class Intent {
    @objc dynamic var app_id = "";
    @objc dynamic var action = "";

    init(_ app_id: String, _ action: String) {
        self.app_id = app_id;
        self.action = action;
    }
 }

 class IntentInfo {
    @objc static let API = 0;
    @objc static let JWT = 1;
    @objc static let URL = 2;

    @objc static let REDIRECT_URL = "redirecturl";
    @objc static let CALLBACK_URL = "callbackurl";
    @objc static let REDIRECT_APP_URL = "redirectappurl";

    @objc dynamic var action: String; // Full action as given by the dapp, including domain and action
    @objc dynamic var params: String?;
    @objc dynamic var fromId: String;
    @objc dynamic var toId: String?;
    @objc dynamic var intentId: Int64 = 0;
    @objc dynamic var silent: Bool = false;
    @objc dynamic var callbackId: String? = nil;
    @objc dynamic var callback: ((String, String?, String)->(Void))? = nil;

    @objc dynamic var filter: IntentFilter? = nil;

    @objc dynamic var responseJwt: String? = nil // JWT output generated by the dapp or service that has handled the intent.
    @objc dynamic var originalJwtRequest: String? = nil
    @objc dynamic var redirecturl: String?;
    @objc dynamic var callbackurl: String?;
    @objc dynamic var redirectappurl: String?;
    @objc dynamic var aud: String?;
    @objc dynamic var req: String?;
    @objc dynamic var type = API;

    var isDoingResponse = false;

    init(_ action: String, _ params: String?, _ fromId: String, _ toId: String?,
         _ intentId: Int64, _ silent: Bool) {
        self.action = action;
        self.params = params;
        self.fromId = fromId;
        self.toId = toId;
        self.intentId = intentId;
        self.silent = silent;
    }

    convenience init(_ action: String, _ params: String?, _ fromId: String, _ toId: String?,
                     _ intentId: Int64, _ silent: Bool, _ callbackId: String?) {
        self.init(action, params, fromId, toId, intentId, silent);
        self.callbackId = callbackId;
    }

    convenience init(_ action: String, _ params: String?, _ fromId: String, _ toId: String?,
                     _ intentId: Int64, _ silent: Bool, _ callback: ((String, String?, String)->(Void))?) {
        self.init(action, params, fromId, toId, intentId, silent);
        self.callback = callback;
    }

    func isJSApp() -> Bool {
        return self.callbackId != nil;
    }

    func isNativeApp() -> Bool {
        return self.callback != nil;
    }
 }

 class IntentPermission {
    let name: String;
    var senderList = [String]();
    var receiverList = [String]();

    init(_ name: String) {
        self.name = name;
    }

    func addSender(_ appId: String) {
        senderList.append(appId);
    }

    func addReceiver(_ appId: String) {
        receiverList.append(appId);
    }

    func senderIsAllow(_ appId: String) -> Bool {
        return senderList.contains(appId);
    }

    func receiverIsAllow(_ appId: String) -> Bool {
        return receiverList.contains(appId);
    }
 }

 class ShareIntentParams {
    var title: String?
    var url: URL?
 }

 class OpenUrlIntentParams {
    var url: URL?
 }

 class IntentManager {
    static let MAX_INTENT_NUMBER = 20;
    static let JWT_SECRET = "secret";
    private static let LOG_TAG = "IntentManager"

    private var intentList = [String: [IntentInfo]]();
    private var intentContextList = [Int64: IntentInfo]();
    private var intentIdList = [String: [Int64]]();

    private var permissionList = [String: IntentPermission]();

    private let appManager: AppManager;
    private static var intentManager: IntentManager?;

    static let trinitySchemes: [String] = [
        "elastos://",
        "https://scheme.elastos.org/",
        "https://did.elastos.net/",
        "https://wallet.elastos.net/"
    ];

    init() {
        self.appManager = AppManager.getShareInstance();
        do {
            try parseIntentPermission();
        }
        catch let error {
            print("Parse intent.json error: \(error)");
        }
        IntentManager.intentManager = self;
    }

    static func getShareInstance() -> IntentManager {
        if (IntentManager.intentManager == nil) {
            IntentManager.intentManager = IntentManager();
        }
        return IntentManager.intentManager!;
    }

    static func checkTrinityScheme(_ url: String) -> Bool {
        for trinityScheme in IntentManager.trinitySchemes {
            if (url.hasPrefix(trinityScheme)) {
                return true;
            }
        }

        // For trinity native, also use native.scheme from config.json as a "trinity scheme" to handle incoming intents
        if ConfigManager.getShareInstance().isNativeBuild() {
            do {
                let nativeSchemeConfig = ConfigManager.getShareInstance().getDictionaryValue("native.scheme")
                let nativeScheme = nativeSchemeConfig!["scheme"]! + "://" + nativeSchemeConfig!["path"]!
                if url.hasPrefix(nativeScheme) {
                    return true
                }
            }
            catch (let e) {
                print(e.localizedDescription)
            }
        }


        return false;
    }

    static func openUrl(_ url: URL) {
        if #available(iOS 10, *) {
            UIApplication.shared.open(url, options: [:],
                                      completionHandler: {
                                        (success) in
            })
        }
        else {
            UIApplication.shared.openURL(url);
        }
    }

    private func getIdbyFilter(_ filter:IntentFilter) -> String {
        return appManager.getIdbyStartupMode(filter.packageId, startupMode:filter.startupMode, serviceName:filter.serviceName);
    }

    private func addIntentToList(_ info: IntentInfo) {
        let id = getIdbyFilter(info.filter!)
        if (intentList[id] == nil) {
            intentList[id] = [IntentInfo]();
        }
        intentList[id]!.append(info);
    }

    func setIntentReady(_ id: String) throws {
        var infos = intentList[id];
        if (infos == nil || infos!.isEmpty) {
            return;
        }

        for info in infos! {
            try doIntent(info);
        }

        infos!.removeAll();
        intentList.removeValue(forKey: id);
    }

    func getIntentCount(_ id: String) ->Int {
        let infos = intentList[id];
        if ((infos == nil) || (infos!.count < 1)) {
            return 0;
        }

        return infos!.count;
    }

    //TODO:: synchronized?
    private func saveIntentContext(_ info: IntentInfo) {
        var intentInfo = intentContextList[info.intentId];
        while (intentInfo != nil) {
            info.intentId += 1;
            intentInfo = intentContextList[info.intentId];
        }

        intentContextList[info.intentId] = info;
        var ids = intentIdList[info.fromId];
        if (ids != nil) {
            while (ids!.count > IntentManager.MAX_INTENT_NUMBER) {
                let intentId = ids![0];
                ids!.remove(at: 0);
                intentContextList.removeValue(forKey: intentId);
            }
        }
        else {
            ids = [Int64]();
            intentIdList[info.fromId] = ids;
        }
        ids!.append(info.intentId);
    }

    public func removeAppFromIntentList(_ id: String) throws {
        for (intentId, info) in intentContextList {
            let modeId = getIdbyFilter(info.filter!);
            if (modeId != nil && modeId == id && !info.isDoingResponse) {
                if (info.type == IntentInfo.API) {
                    let viewController: TrinityViewController? = appManager.getViewControllerById(info.fromId);
                    if (viewController != nil) {
                        if (info.filter!.startupMode == AppManager.STARTUP_APP) {
                            try appManager.start(info.fromId, AppManager.STARTUP_APP, nil);
                        }
                        info.params = nil;
                        viewController!.basePlugin!.onReceiveIntentResponse(info);
                    }
                }
                intentContextList[intentId] = nil;
            }
            else if (info.fromId == id) {
                intentContextList[intentId] = nil;
                if (info.filter!.startupMode == AppManager.STARTUP_INTENT
                    || info.filter!.startupMode == AppManager.STARTUP_SILENCE) {
                    try appManager.close(info.filter!.packageId, info.filter!.startupMode, info.filter!.serviceName);
                }
            }
        }
    }

    public func setDoingResponse(_ intentId: Int64 ) throws {
        let info = intentContextList[intentId];
        if (info == nil) {
            throw AppError.error(String(intentId) + " isn't exist!");
        }

        info!.isDoingResponse = true;
    }

    func getIntentFilter(_ action: String) throws -> [IntentFilter] {
        let filters = try appManager.dbAdapter.getIntentFilter(action);
        var list = [IntentFilter]();

        for filter in filters {
            if (getIntentReceiverPermission(action, filter.packageId)) {
                list.append(filter);
            }
        }

        return list;
    }

    private func popupIntentChooser(_ info: IntentInfo, _ filters: [IntentFilter]) {
        // More than one possible handler, show a chooser and pass it the selectable apps info.
        var appInfos: [AppInfo] = []
        for filter in filters {
            if let info = appManager.getAppInfo(filter.packageId) {
                appInfos.append(info)
            }
        }

        // Create the dialog
        let vc = IntentActionChooserController(nibName: "IntentActionChooserController", bundle: Bundle.main)

        vc.setAppManager(appManager: appManager)
        vc.setAppInfos(appInfos: appInfos)

        // Special "share" case: add a specific entry for native OS "share" action
        if info.action == "share" {
            vc.useNativeShare(shareIntentParams: extractShareIntentParams(info))
        }

        let popup = PopupDialog(viewController: vc)
        let cancelButton = CancelButton(title: "cancel".localized) {}
        popup.addButtons([cancelButton])

        vc.setListener() { selectedAppInfo in
            popup.dismiss() {
                // Now we know the real app that should receive the intent.
                for filter in filters {
                    if filter.packageId ==  selectedAppInfo.app_id {
                        info.filter = filter;
                        info.toId = self.getIdbyFilter(info.filter!);
                        break;
                    }
                }
                try! self.sendIntent(info)
            }
        }

        if info.action == "share" {
            vc.setNativeShareListener {
                popup.dismiss() {
                    self.sendNativeShareAction(info)
                }
            }
        }

        // Present the dialog
        self.appManager.mainViewController.present(popup, animated: true, completion: nil)
    }

    func doIntent(_ info: IntentInfo) throws {
        // Trinity native: dismiss any target app. We use only the full intent domain. dapp package id makes not sense here
        if ConfigManager.getShareInstance().isNativeBuild() {
            info.toId = nil
        }

        if (info.toId == nil) {
            let filters = try getIntentFilter(info.action);

            // Throw an error in case no one can handle the action.
            // Special case for the "share" action that is always handled by the native OS too.
            if info.action != "share" && info.action != "openurl" {
                if filters.isEmpty {
                    if !ConfigManager.getShareInstance().isNativeBuild() {
                        // Not a native build - so 0 filter means no one can handle the action
                        throw AppError.error("Intent action '\(info.action)' isn't supported!")
                    }
                    else {
                        // We are a trinity native build - launch that action as native intent
                        try sendIntentToNativeOS(info: info)
                        return
                    }
                }
            }

            if !getIntentSenderPermission(info.action, info.fromId) {
                throw AppError.error(info.action + " isn't permission!")
            }

            // If there is only one application able to handle this intent, we directly use it.
            // Otherwise, we display a prompt so that user can pick the right application.
            // "share" action is special, as it must deal with the native share action.
            if info.action == "openurl" {
                // We don't let apps handle the openurl intent. It's always a native call.
                sendNativeOpenUrlAction(info: info)
            }
            else if info.action != "share" {
                if filters.count == 1 {
                    info.toId = getIdbyFilter(filters[0])
                    info.filter = filters[0]
                    try sendIntent(info)
                }
                else {
                    popupIntentChooser(info, filters)
                }
            }
            else {
                // Action is "share"
                if filters.count == 0 {
                    // No dapp can handle share. Directly send the native action
                    sendNativeShareAction(info)
                }
                else {
                    // Show a popup chooser. It will add the native share action.
                    popupIntentChooser(info, filters)
                }
            }
        }
        else if info.filter == nil {
            let filters = try getIntentFilter(info.action)
            for filter in filters {
                if (info.toId!.starts(with: filter.packageId)) {
                    info.filter = filter
                    try sendIntent(info)
                    return
                }
            }
            throw AppError.error("The appid[\(info.toId)]'s intent action '\(info.action)' isn't supported!")
        }
        else {
            try sendIntent(info)
        }
    }

    private func sendIntent(_ info: IntentInfo) throws {
        let id =  getIdbyFilter(info.filter!);
        let viewController = appManager.getViewControllerById(id)
        if (viewController != nil && viewController!.basePlugin!.isIntentReady()) {
            saveIntentContext(info);
            if (!appManager.isCurrentViewController(viewController!)) {
                try appManager.start(info.filter!.packageId, info.filter!.startupMode, info.filter!.serviceName);
                try appManager.sendLauncherMessageMinimize(info.fromId);
            }
            viewController!.basePlugin!.onReceiveIntent(info);
        }
        else {
            addIntentToList(info);
            try appManager.start(info.filter!.packageId, info.filter!.startupMode, info.filter!.serviceName);
            try appManager.sendLauncherMessageMinimize(info.fromId);
        }
    }

    public static func parseJWT(_ jwt: String) throws -> [String: Any]? {
        let jwtDecoder = SwiftJWT.JWTDecoder.init(jwtVerifier: .none)
        let data = jwt.data(using: .utf8) ?? nil
        if data == nil {
            throw AppError.error("parseJWT error!")
        }
        let decoded = try? jwtDecoder.decode(SwiftJWT.JWT<AnyCodable>.self, from: data!)
        if decoded == nil {
            throw AppError.error("parseJWT error!")
        }
        return decoded?.claims.value as? [String: Any]
    }

    func getParamsByJWT(_ jwt: String, _ info: IntentInfo) throws {
        var jwtPayload = try IntentManager.parseJWT(jwt)
        if jwtPayload == nil {
            throw AppError.error("getParamsByJWT error!")
        }

        jwtPayload!["type"] = "jwt";
        info.params = jwtPayload!.toString();

        if (jwtPayload!["iss"] != nil) {
            info.aud = (jwtPayload!["iss"] as! String);
        }
        if let appid = jwtPayload!["appid"] {
            // info.req = (jwtPayload!["appid"] as! String);
            // Compatible with int and string.(Usually the appid is string)
            info.req = "\(appid)"
        }
        if (jwtPayload![IntentInfo.REDIRECT_URL] != nil) {
            info.redirecturl = (jwtPayload![IntentInfo.REDIRECT_URL] as! String);
        }
        else if (jwtPayload![IntentInfo.CALLBACK_URL] != nil) {
            info.callbackurl = (jwtPayload![IntentInfo.CALLBACK_URL] as! String);
        }
        info.type = IntentInfo.JWT
        info.originalJwtRequest = jwt
    }

    func getParamsByUri(_ params: [String: String], _ info: IntentInfo) {
        var json = Dictionary<String, Any>()
        for (key, value) in params {
            if (key == IntentInfo.REDIRECT_URL) {
                info.redirecturl = value;
            }
            else if (key == IntentInfo.CALLBACK_URL) {
                info.callbackurl = value;
            }
            else if (key == IntentInfo.REDIRECT_APP_URL) {
                info.redirectappurl = value;
            }
            else {
                if (key == "iss") {
                    info.aud = value;
                }
                else if (key == "appid") {
                    info.req = value;
                }

                if isJSONType(value) {
                    json[key] = value.toDict()
                }
                else {
                    json[key] = value
                }
            }
        }
        info.type = IntentInfo.URL
        info.params = json.toString() ?? ""
    }

    func  parseIntentUri(_ _uri: URL, _ fromId: String) throws -> IntentInfo? {
        var info: IntentInfo? = nil;
        var uri = _uri;
        var url = uri.absoluteString;
        if (url.hasPrefix("elastos://") && !url.hasPrefix("elastos:///")) {
            url = "elastos:///" + (url as NSString).substring(from: 10);
            uri = URL(string: url)!;
        }
        var pathComponents = uri.pathComponents;
        pathComponents.remove(at: 0);

        if (pathComponents.count > 0) {
            let action = pathComponents[0];
            let params = uri.parametersFromQueryString;

            let currentTime = Int64(Date().timeIntervalSince1970);

            info = IntentInfo(action, nil, fromId, nil, currentTime, false)
            if (params != nil && params!.count > 0) {
                getParamsByUri(params!, info!);
            }
            else if (pathComponents.count == 2) {
                try getParamsByJWT(pathComponents[1], info!);
            }
        }
        return info;
    }

    /**
     * Returns the native app scheme that allows opening this app from native intents.
     * For example the elastOS DID demo packaged by trinity native, this would be https://diddemo.trinity-tech.io.
     * Hyper IM would have https://app.hyperim.org, etc.
     */
    private func getNativeAppScheme() throws -> String {
        let schemeConfig = ConfigManager.getShareInstance().getDictionaryValue("native.scheme")
        if schemeConfig == nil {
            throw "No native app scheme found in config.json !"
        }

        return schemeConfig!["scheme"]! + "://" + schemeConfig!["path"]!
    }

    // Opposite of parseIntentUri().
    // From intent info params to url params.
    // Ex: info.params = "{a:1, b:{x:1}}" returns url?a=1&b={x:1}
    private func createUriParamsFromIntentInfoParams(url: String, params: Dictionary<String, Any>) throws -> String {
        var url = url
        if (url.contains("?")) {
            url = url + "&"
        }
        else {
            url = url + "?"
        }

        var firstLevelKeys = params.keys.makeIterator()
        while let key = firstLevelKeys.next() {
            let value = params[key]
            let serializedValue: String
            if let v = (value as? Dictionary<String, Any>) {
                serializedValue = v.toString()!
            }
            else {
                serializedValue = "\(value ?? "")"
            }
            url += key + "=" + serializedValue.encodingQuery() + "&"
        }

        // If there is no redirect url, we add one to be able to receive responses
        if !params.keys.contains("redirecturl") {
            // "intentresponse" is added For trinity native. NOTE: we should maybe move this out of this method
            url = url + "&redirecturl="+(try getNativeAppScheme())+"/intentresponse" // Ex: https://diddemo.elastos.org/intentresponse
        }

        print("INTENT DEBUG: " + url)
        return url
    }


    func sendIntentByUri(_ uri: URL, _ fromId: String) throws {
        let info = try parseIntentUri(uri, fromId);
        if (info != nil && info!.params != nil) {
            // We are receiving an intent from an external application. Do some sanity check.
            try checkExternalIntentValidity(info: info!) {
                isValid, errorMessage in
                if isValid {
                    do {
                        try self.doIntent(info!)
                    } catch (let e) {
                        print(e.localizedDescription)
                    }
                }
                else {
                    // TODO: clear popup error message to user.
                    print(errorMessage)
                }
            }
        }
    }

    func doIntentByUri(_ uri: URL) {
        do {
            try sendIntentByUri(uri, "system");
        }
        catch let error {
            print("doIntentByUri: \(error)");
        }
    }

    typealias OnExternalIntentValidCallback = (_ isValid: Bool, _ errorMessage: String?)->Void

    private func checkExternalIntentValidity(info: IntentInfo, onExternalIntentValid: @escaping OnExternalIntentValidCallback) throws {
        // If the intent contains an appDid param and a redirectUrl, then we must check that they match.
        // This means that the app did document from the ID chain must contain a reference to the expected redirectUrl.
        // This way, we make sure that an application is not trying to act on behalf of another one by replacing his DID.
        // Ex: access to hive vault.
        if info.redirecturl != nil {
            do {
                let params = info.params!.toDict()!
                if params.keys.contains("appdid") {
                    // So we need to resolve this DID from chain and make sure that it matches the target redirect url
                    try checkExternalIntentValidityForAppDID(info: info, appDid: params["appdid"]! as! String, onExternalIntentValid: onExternalIntentValid)
                } else {
                    onExternalIntentValid(true, nil)
                }
            } catch (let e) {
                print(e.localizedDescription)
                onExternalIntentValid(false, "Intent parameters must be a JSON object")
            }
        }
        else {
            onExternalIntentValid(true, nil)
        }
    }

    private func checkExternalIntentValidityForAppDID(info: IntentInfo, appDid: String, onExternalIntentValid: @escaping OnExternalIntentValidCallback) throws {
        // DIRTY to call the DID Plugin from here, but no choice for now because of the static DID back end...
        try DIDPlugin.initializeDIDBackend()

        DispatchQueue.init(label: "CheckExtIntentValidity").async {
            var didDocument: DIDDocument? = nil
            do {
                if let didDocument = try DID(appDid).resolve(true) {
                    // DID document found. Look for the #native -> redirectUrl credential
                    if let nativeCredential = try didDocument.credential(ofId: "#native") {
                        if let onChainRedirectUrl = nativeCredential.subject.getPropertyAsString(ofName:"redirectUrl") {
                            // We found a redirect url in the app DID document. Check that it matches the one in the intent
                            if (info.redirecturl!.hasPrefix(onChainRedirectUrl)) {
                                // Everything ok.
                                onExternalIntentValid(true, nil)
                            }
                            else {
                                onExternalIntentValid(false, "The registered redirect url in the App DID document ("+onChainRedirectUrl+") doesn't match with the received intent redirect url")
                            }
                        }
                        else {
                            onExternalIntentValid(false, "No redirectUrl found in the app DID document. Was the app registered on the DID chain?")
                        }
                    }
                    else {
                        onExternalIntentValid(false, "No #native credential found in the app DID document. Was the app registered on the DID chain?")
                    }
                }
                else { // Not found
                    onExternalIntentValid(false, "No DID found on chain matching the application DID "+appDid)
                }
            }
            catch (let e) {
                onExternalIntentValid(false, e.localizedDescription)
            }
        }
    }


    func createUnsignedJWTResponse(_ info: IntentInfo, _ result: String) throws -> String? {
        var claims = result.toDict();
        if (claims == nil) {
            throw AppError.error("createJWTResponse: result error!");
        }
        claims!["req"] = info.req;
        let jwt = SwiftJWT.JWT<AnyCodable>(claims: AnyCodable(claims!))
        let jwtEncoder = SwiftJWT.JWTEncoder(jwtSigner: .none)
        let encodedData = try jwtEncoder.encode(jwt)
        return String(data:encodedData, encoding: .utf8)
    }

    func createUrlResponse(_ info: IntentInfo, _ result: String) -> String? {
        var ret = result.toDict();
        if ret == nil {
            ret = [String: Any]();
        }
        if (info.req != nil) {
            ret!["req"] = info.req;
        }
        if (info.aud != nil) {
            ret!["aud"] = info.aud;
        }
        ret!["iat"] = Int64(Date().timeIntervalSince1970)/1000;
        ret!["method"] = info.action;
        return ret!.toString();
    }

    func postCallback(_ name: String, _ value: String, _ callbackurl: String) throws {

        let url = URL(string: callbackurl)!
        var request = URLRequest(url: url)
        request.httpMethod = "POST";
        request.setValue("application/json;charset=UTF-8", forHTTPHeaderField: "Content-Type");
        request.setValue("application/json", forHTTPHeaderField: "Accept")

        let parameters: [String: String] = [
            name: value
        ]
        request.httpBody = try JSONSerialization.data(withJSONObject: parameters)

        let task = URLSession.shared.dataTask(with: request, completionHandler: { (data, response, error) -> Void in

            guard let data = data,
                let response = response as? HTTPURLResponse,
                error == nil else {                                              // check for fundamental networking error
                    print("error", error ?? "Unknown error")
                    //                throw AppError.error("postCallback error:" + error ?? "Unknown error");
                    return
            }

            if !((200 ... 299) ~= response.statusCode) {                    // check for http errors
                print("Error - statusCode should be 2xx, but is \(response.statusCode)")
                print("response = \(response)")

                if let responseString = String(data: data, encoding: .utf8) {
                    print("responseString = \(responseString)")
                }
            }
            else {
                Log.d(IntentManager.LOG_TAG, "Intent callback url responsed with success (2** http code)")
            }
        })

        task.resume()
    }

    func getResultUrl(_ url: String, _ result: String) -> String {
        var param = "?result=";
        if (url.contains("?")) {
            param = "&result=";
        }
        return URL(string: url + param + result.encodingQuery())!.absoluteString;
    }

    /**
     * Helper class to deal with app intent result types that can be either JSON objects with raw data,
     * or JSON objects with "jwt" special field.
     */
    private class IntentResult {
        let rawResult: String
        var payload: Dictionary<String, Any>? = nil
        var jwt: String? = nil

        init(rawResult: String) throws {
            self.rawResult = rawResult

            if let resultAsJson = rawResult.quotedJsonStringKeys().toDict() {
                if resultAsJson.keys.contains("jwt") {
                    // The result is a single field named "jwt", that contains an already encoded JWT token
                    jwt = resultAsJson["jwt"] as? String
                    if jwt != nil {
                        payload = try parseJWT(jwt!)
                    }
                    else {
                        payload = nil
                    }
                }
                else {
                    // The result is a simple JSON object
                    payload = resultAsJson
                }
            }
            else {
                // Unable to understand the passed result as JSON
                payload = nil
            }
        }

        func payloadAsString() -> String {
            return payload!.toString()!
        }

        func isAlreadyJWT() -> Bool {
            return jwt != nil
        }
    }

    func sendIntentResponse(_ result: String, _ intentId: Int64, _ fromId: String) throws {
        let info = intentContextList[intentId]
        if (info == nil) {
            throw AppError.error("Intent with ID " + intentId.value + " doesn't exist!")
        }

        var viewController: TrinityViewController? = nil
        viewController = appManager.getViewControllerById(info!.fromId)
        if (!info!.silent && viewController != nil && viewController!.startupMode == AppManager.STARTUP_APP) {
            try self.appManager.start(info!.fromId, AppManager.STARTUP_APP, nil)
        }

        // The result object can be either a standard json object, or a {jwt:JWT} object.
        let intentResult = try IntentResult(rawResult: result)

        if (info!.type == IntentInfo.API) {
            // The intent was sent by a trinity dapp, inside trinity, so we call the intent response callback
            if viewController != nil {
                info!.params = intentResult.payloadAsString()
                // If the called dapp has generated a JWT as output, we pass the decoded payload to the calling dapp
                // for convenience, but we also forward the raw JWT as this is required in some cases.
                if intentResult.isAlreadyJWT() {
                    info!.responseJwt = intentResult.jwt
                }
                viewController!.basePlugin!.onReceiveIntentResponse(info!)
            }
        }
        else if (info!.redirectappurl != nil && viewController != nil && viewController!.basePlugin!.isUrlApp()) {
            let url = getResultUrl(info!.redirectappurl!, result)
            viewController!.loadUrl(URL(string: url)!)
        }
        else {
            var urlString = info!.redirecturl
            if (urlString == nil) {
                urlString = info!.callbackurl
            }

            // If there is a provided URL callback for the intent, we want to send the intent response to that url
            if (urlString != nil) {
                var jwt: String? = nil
                if intentResult.isAlreadyJWT() {
                    jwt = intentResult.jwt
                }
                else {
                    // App did not return a JWT, so we return an unsigned JWT instead
                    jwt = try createUnsignedJWTResponse(info!, result)
                }

                if (IntentManager.checkTrinityScheme(urlString!)) {
                    // Response url is a trinity url that we can handle internally
                    if intentResult.isAlreadyJWT() {
                        urlString = urlString! + "/" + jwt!
                    }
                    else {
                        urlString = getResultUrl(urlString!, intentResult.payloadAsString()) // Pass the raw data as a result= field
                    }
                    try sendIntentByUri(URL(string: urlString!)!, info!.fromId);
                } else {
                    // Response url can't be handled by trinity. So we either call an intent to open it, or HTTP POST data
                    if (info!.redirecturl != nil) {
                        if intentResult.isAlreadyJWT() {
                            urlString = info!.redirecturl! + "/" + jwt!
                        }
                        else {
                            urlString = getResultUrl(urlString!, intentResult.payloadAsString()) // Pass the raw data as a result= field
                        }
                        IntentManager.openUrl(URL(string: urlString!)!)
                    } else if (info!.callbackurl != nil) {
                        if (intentResult.isAlreadyJWT()) {
                            try postCallback("jwt", jwt!, info!.callbackurl!)
                        }
                        else {
                            try postCallback("result", intentResult.payloadAsString(), info!.callbackurl!)
                        }
                    }
                }
            }
        }

        intentContextList[intentId] = nil;
        if (info!.filter != nil && (info!.filter!.startupMode == AppManager.STARTUP_INTENT
            || info!.filter!.startupMode == AppManager.STARTUP_SILENCE)) {
            try appManager.close(info!.filter!.packageId, info!.filter!.startupMode, info!.filter!.serviceName);
        }
    }

    func parseIntentPermission() throws {
        let path = getAbsolutePath("www/config/permission/intent.json");
        let json = try getJsonFromFile(path) as! [String: [String: [String]]];

        for (intent, value) in json {
            let intentPermission = IntentPermission(intent);
            let senders = value["sender"]!;
            for appId in senders {
                intentPermission.addSender(appId);
            }

            let receivers = value["receiver"]!;
            for appId in receivers {
                intentPermission.addReceiver(appId);
            }
            permissionList[intent] = intentPermission;
        }
    }

    func getIntentSenderPermission(_ intent: String, _ appId: String) ->Bool {
        let intentPermission = permissionList[intent];
        if (intentPermission == nil) {
            return true;
        }

        return intentPermission!.senderIsAllow(appId);
    }

    func getIntentReceiverPermission(_ intent: String, _ appId: String) ->Bool {
        let intentPermission = permissionList[intent];
        if (intentPermission == nil) {
            return true;
        }

        return intentPermission!.receiverIsAllow(appId);
    }

    private func extractShareIntentParams(_ info: IntentInfo) -> ShareIntentParams? {
        // Extract JSON params from the share intent. Expected format is {title:"", url:""} but this
        // could be anything as this is set by users.
        guard let params = info.params else {
            print("Share intent params are not set!")
            return nil
        }

        guard let fields = params.toDict() else {
            print("Share intent parameters are not JSON format")
            return nil
        }

        let shareIntentParams = ShareIntentParams()

        shareIntentParams.title  = fields["title"] as? String

        if let url = fields["url"] as? String {
            if let parsedUrl = URL(string: url) {
                shareIntentParams.url = parsedUrl
            }
        }

        return shareIntentParams
    }

    func sendNativeShareAction(_ info: IntentInfo) {
        if let extractedParams = extractShareIntentParams(info) {
            var activityItems: [Any] = [];

            if let title = extractedParams.title {
                activityItems.append(title)
            }
            if let url = extractedParams.url {
                activityItems.append(url)
            }

            let vc = UIActivityViewController(activityItems: activityItems, applicationActivities: [])
            self.appManager.curController!.present(vc, animated: true, completion: nil)
        }
    }

    private func extractOpenUrlIntentParams(info: IntentInfo) -> OpenUrlIntentParams? {
        // Extract JSON params from the open url intent. Expected format is {url:""}.
        if info.params == nil {
            print("Openurl intent params are not set!")
            return nil
        }

        if let jsonParams = info.params!.toDict() {
            let openUrlIntentParams = OpenUrlIntentParams()

            if jsonParams.keys.contains("url"), let url = jsonParams["url"] as? String {
                openUrlIntentParams.url = URL(string: url)
            }
            return openUrlIntentParams
        }
        else    {
            print("Openurl intent parameters are not JSON format")
            return nil
        }
    }

    func sendNativeOpenUrlAction(info: IntentInfo) {
        if let extractedParams = extractOpenUrlIntentParams(info: info) {
            // Can't send an empty open url action
            if extractedParams.url == nil {
                return
            }

            UIApplication.shared.open(URL(string: extractedParams.url!.absoluteString)!, options: [:], completionHandler: nil)
        }
    }

    private var tmpOnGoingNativeIntentInfo: IntentInfo? = nil

    // TODO - QUICK AND DIRTY ATTEMPT - FULL IMPROVEMENT NEEDED
    public func onExternalIntentResponseReceived(uri: URL) {
        print("RECEIVED: "+uri.absoluteString)

        var resultStr: String? = nil
        if (uri.absoluteString.contains("result=")) {
            // Result received as a raw string / raw json string
            resultStr = uri.parametersFromQueryString!["result"]
        }
        else {
            // Consider the received result as a JWT token
            resultStr = "{jwt:\""+uri.lastPathComponent+"\"}";
        }
        print(resultStr ?? "error")
        //let controller = appManager.getViewControllerById(tmpOnGoingNativeIntentInfo!.fromId)

        do {
            try sendIntentResponse(resultStr!, tmpOnGoingNativeIntentInfo!.intentId, tmpOnGoingNativeIntentInfo!.fromId)
            tmpOnGoingNativeIntentInfo = nil
        } catch (let e) {
            print(e.localizedDescription)
        }
    }

    // Serializes a sendIntent(info) command info into a url such as https://domain/action/?stringifiedJsonResponseParams
    // And sends that url to the native OS.
    func sendIntentToNativeOS(info: IntentInfo) throws {
        // TMP - move to config.json mapping maybe (dongxiao).
        // Backward compatibility: converts old style "credaccess"-like intent calls to full domain
        // calls such as https://did.elastos.net/credaccess.
        switch (info.action) {
            case "credaccess", "appidcredissue", "credimport", "credissue", "didsign", "promptpublishdid",
                 "registerapplicationprofile", "sethiveprovider":
                info.action = "https://did.elastos.net/"+info.action
                break
            case "pay", "walletaccess", "crmembervote", "dposvotetransaction", "didtransaction", "esctransaction":
                info.action = "https://wallet.elastos.net/"+info.action
                break
        default:
            break
        }
        // END TMP

        if !isJSONType(info.params!) {
            throw "Intent parameters must be a JSON object"
        }

        // Convert intent info params into a serialized json string for the target url
        var params = info.params!.toDict()

        // Append the current application DID to the intent to let the receiver guess who is requesting
        // (but that will be checked on ID chain with the redirect url).
        // For example, in order to send a "app id credential" that gives rights to the calling app to access a hive vault,
        // We must make sure that the calling trinity native app is who it pretends to be, to not let it access the hive storage space
        // of another app. For this, we don't blindly trust the sent appDid here, but the receiving trinity runtime will
        // fetch this app did from chain, and will make sure that the redirect url registered in the app did public document
        // matches with the redirect url used in this intent.
        params!["appDid"] = appManager.getAppInfo(info.fromId)!.did

        let url = try createUriParamsFromIntentInfoParams(url: info.action, params: params!) // info.action must be a full action url such as https://did.elastos.net/credaccess

        do {
            tmpOnGoingNativeIntentInfo = info // TODO - TMP DIRTY
            saveIntentContext(info) // TODO - TMP DIRTY

            UIApplication.shared.open(URL(string: url)!, options: [:], completionHandler: nil)
        }
        catch let error {
            print("No native application able to open this intent")
        }
    }
 }


